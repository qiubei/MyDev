# å¸¸ç”¨çš„é“¾å¼æ–¹æ³•è¯´æ˜

## åˆ†äº«ç›®çš„

1. æ‰«ç›²ï¼ˆæœ‰å¯èƒ½æ˜¯ä¸ªäººç›²åŒºï¼‰ã€‚
2. ç®€å•äº†è§£ä»€ä¹ˆæ˜¯å‡½æ•°å¼å˜æˆã€‚
3. äº†è§£ä¸€äº›æ–¹æ³•çš„åŸºæœ¬ä½¿ç”¨ã€‚
4. ä¸ªäººæå‡ã€‚

## å‡½æ•°å¼ç¼–ç¨‹è¯´æ˜ï¼ˆäº‘é‡Œé›¾é‡Œï¼Œç…§æœ¬å®£ç§‘ï¼‰

ã€‚ã€‚ã€‚

## RxSwift åŸºç¡€ 

**é“¾å¼ç¼–ç¨‹çš„è®¾è®¡å…±æ€§**

- äº‹ä»¶çŠ¶æ€
- äº’æ–¥ä¿¡å·
- äº‹ä»¶é˜Ÿåˆ—

~~~ installer
// installer

public final class Signal<T> {
    
    fileprivate var value: Result<T>?
    fileprivate var callbacks: [(Result<T>) -> Void] = []
    fileprivate let mutex = Mutex() // äº’æ–¥ä¿¡å·
    ...
}
~~~

~~~Promise
// Promise

public final class Promise<Value> {
    
    private var state: State<Value>
    private let lockQueue = DispatchQueue(label: "promise_lock_queue", qos: .userInitiated)
    private var callbacks: [Callback<Value>] = []
    ...
}
~~~

RxSwift ç†è®ºä¸Šæ˜¯å·®ä¸å¤šçš„ï¼Œä½†æ˜¯...

~~~swift 
/// Type of elements in sequence.
    public typealias E = Element
    
    init() {
#if TRACE_RESOURCES
        _ = Resources.incrementTotal()
#endif
    }
    
    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
        rxAbstractMethod()
    }
    
    public func asObservable() -> Observable<E> {
        return self
    }
    
    deinit {
#if TRACE_RESOURCES
        _ = Resources.decrementTotal()
#endif
    }

    // this is kind of ugly I know :(
    // Swift compiler reports "Not supported yet" when trying to override protocol extensions, so Â¯\_(ãƒ„)_/Â¯

    /// Optimizations for map operator
    internal func composeMap<R>(_ transform: @escaping (Element) throws -> R) -> Observable<R> {
        return _map(source: self, transform: transform)
    }
~~~

**Rxswift åŸºæœ¬æ„æˆè¦ç´ **
- ObservableType æ˜¯ä¸€ä¸ª `protocol`ï¼Œ æ‰€æœ‰æ‹¥æœ‰é“¾å¼èƒ½åŠ›éƒ½å¿…é¡»å®ç°è¿™ä¸ªåè®®ã€‚

~~~
    func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E
    
    public func asObservable() -> Observable<E> {
        // temporary workaround
        //return Observable.create(subscribe: self.subscribe)
        return Observable.create { o in
            return self.subscribe(o)
        }
    }
~~~

- ObserverType ä¹Ÿæ˜¯åè®®ï¼šåˆ†ä¸¤å±‚ï¼šä¸€ä¸ªæ˜¯å®ç° observable çš„äººè°ƒç”¨ï¼Œä¸€ä¸ªç»™è§‚å¯Ÿè€…è°ƒç”¨

~~~
    /// Notify observer about sequence event.
    ///
    /// - parameter event: Event that occurred.
    func on(_ event: Event<E>)  
    
    
    /// Convenience method equivalent to `on(.next(element: E))`
    ///
    /// - parameter element: Next element to send to observer(s)
    public func onNext(_ element: E) {
        self.on(.next(element))
    }
    
    /// Convenience method equivalent to `on(.completed)`
    public func onCompleted() {
        self.on(.completed)
    }
    
    /// Convenience method equivalent to `on(.error(Swift.Error))`
    /// - parameter error: Swift.Error to send to observer(s)
    public func onError(_ error: Swift.Error) {
        self.on(.error(error))
    }

~~~


```è¯·ä¸è¦å† bb äº†ï¼Œå‘Šè¯‰æˆ‘ä»€ä¹ˆå‡½æ•°æ˜¯ç¼–ç¨‹ã€‚ã€‚ã€‚SHOW ME THE CODE!!!```

## RxSwift simple Demo

~~~
let disposeBag = DisposeBag()
let faces = Observable<String>.create { observerOfString in
    print("Observable created")
    observerOfString.on(.next("ğŸ˜‰"))
    observerOfString.on(.next("ğŸ°"))
    observerOfString.on(.next("ğŸ¶"))
    observerOfString.on(.completed)
    return Disposables.create()
    }

faces.subscribe { (event) in
    print(event)
}.disposed(by: disposeBag)
/// console log
/*
 Hello world1
 Observable created
 next(ğŸ˜‰)
 next(ğŸ°)
 next(ğŸ¶)
 completed
 */
~~~

## æ–¹æ³•åˆ—è¡¨

#### åˆ›å»ºå’Œè®¢é˜… Observable

- create

    æˆ‘ä»¬ä¹Ÿå¯ä»¥è‡ªå®šä¹‰å¯è§‚å¯Ÿçš„ sequenceï¼Œé‚£å°±æ˜¯ä½¿ç”¨ create
- never

    never å°±æ˜¯åˆ›å»ºä¸€ä¸ª sequenceï¼Œä½†æ˜¯ä¸å‘å‡ºä»»ä½•äº‹ä»¶ä¿¡å·ã€‚
    
- empty sequence

    emptyå°±æ˜¯åˆ›å»ºä¸€ä¸ªç©ºçš„sequence,åªèƒ½å‘å‡ºä¸€ä¸ª .completed äº‹ä»¶

- just

    justæ˜¯åˆ›å»ºä¸€ä¸ª sequence åªèƒ½å‘å‡ºä¸€ç§ç‰¹å®šçš„äº‹ä»¶ï¼Œèƒ½æ­£å¸¸ç»“æŸ.
    
- of

    of æ˜¯åˆ›å»ºä¸€ä¸ª sequence èƒ½å‘ç”Ÿå¾ˆå¤šç§äº‹ä»¶ä¿¡å·
    
- from

    from å°±æ˜¯ä»é›†åˆä¸­åˆ›å»º sequenceï¼Œä¾‹å¦‚æ•°ç»„ï¼Œå­—å…¸æˆ–è€…Set    
    
- range (æœ‰ç‚¹ç–‘æƒ‘ï¼Œä¸ºä»€ä¹ˆåªèƒ½ä½¿ç”¨æ•´å‹æ•°æ®)

    rangeå°±æ˜¯åˆ›å»ºä¸€ä¸ª sequenceï¼Œä»–ä¼šå‘å‡ºè¿™ä¸ªèŒƒå›´ä¸­çš„ä»å¼€å§‹åˆ°ç»“æŸçš„æ‰€æœ‰äº‹ä»¶
    
- repeatElement
    
    åˆ›å»ºä¸€ä¸ªsequenceï¼Œå‘å‡ºç‰¹å®šçš„äº‹ä»¶næ¬¡
    
- generate

    generateæ˜¯åˆ›å»ºä¸€ä¸ªå¯è§‚å¯Ÿsequenceï¼Œå½“åˆå§‹åŒ–çš„æ¡ä»¶ä¸ºtrueçš„æ—¶å€™ï¼Œä»–å°±ä¼šå‘å‡ºæ‰€å¯¹åº”çš„äº‹ä»¶
    
- deferred

    deferred ä¼šä¸ºæ¯ä¸€ä¸ºè®¢é˜…è€… observer åˆ›å»ºä¸€ä¸ªæ–°çš„å¯è§‚å¯Ÿåºåˆ—
    
- error

    åˆ›å»ºä¸€ä¸ªå¯è§‚å¯Ÿåºåˆ—ï¼Œä½†ä¸å‘å‡ºä»»ä½•æ­£å¸¸çš„äº‹ä»¶ï¼Œåªå‘å‡ºerroräº‹ä»¶å¹¶ç»“æŸ
    
- doOn
    
    doOnæˆ‘æ„Ÿè§‰å°±æ˜¯åœ¨ç›´æ¥onNextå¤„ç†æ—¶å€™ï¼Œå…ˆæ‰§è¡ŒæŸä¸ªæ–¹æ³•ï¼ŒdoOnNext( :)æ–¹æ³•å°±æ˜¯åœ¨subscribe(onNext:)å‰è°ƒç”¨ï¼ŒdoOnCompleted(:)å°±æ˜¯åœ¨subscribe(onCompleted:)å‰é¢è°ƒç”¨çš„ã€‚
    
#### subjects

```DMEO```

~~~ 
let subject1 = PublishSubject<String>()
let subject2 = PublishSubject<String>()
Observable.of(subject1, subject2)
    .merge()
    .subscribe(onNext: {print("mergae -- \($0)")} )
    .disposed(by: disposeBag)
subject1.onNext("a")
subject1.onNext("b")
subject2.onNext("1")
subject2.onNext("2")
subject1.onNext("c")
subject2.onNext("3")
subject1.onNext("d")

~~~


Subjet æ˜¯ observable å’Œ Observer ä¹‹é—´çš„æ¡¥æ¢ï¼Œä¸€ä¸ª Subject æ—¢æ˜¯ä¸€ä¸ª Obserable ä¹Ÿæ˜¯ä¸€ä¸ª Observerï¼Œä»–æ—¢å¯ä»¥å‘å‡ºäº‹ä»¶ï¼Œä¹Ÿå¯ä»¥ç›‘å¬äº‹ä»¶ã€‚

- publishsubject

PublishSubjectä¼šå‘é€è®¢é˜…è€…ä»è®¢é˜…ä¹‹åçš„äº‹ä»¶åºåˆ—ã€‚

- replay subject


    å½“ä½ è®¢é˜… ReplaySubject çš„æ—¶å€™ï¼Œä½ å¯ä»¥æ¥æ”¶åˆ°è®¢é˜…ä»–ä¹‹åçš„äº‹ä»¶ï¼Œä½†ä¹Ÿå¯ä»¥æ¥å—è®¢é˜…ä»–ä¹‹å‰å‘å‡ºçš„äº‹ä»¶ï¼Œæ¥å—å‡ ä¸ªäº‹ä»¶å–å†³ä¸ bufferSize çš„å¤§å°
    
- BehaviorSubject

- variable

    Variable æ˜¯ BehaviorSubject ä¸€ä¸ªåŒ…è£…ç®±ï¼Œå°±åƒæ˜¯ä¸€ä¸ªç®±å­ä¸€æ ·ï¼Œä½¿ç”¨çš„æ—¶å€™éœ€è¦è°ƒç”¨ asObservable() æ‹†ç®±ï¼Œé‡Œé¢çš„ value æ˜¯ä¸€ä¸ª BehaviorSubject ï¼Œä»–ä¸ä¼šå‘å‡º error äº‹ä»¶ï¼Œä½†æ˜¯ä¼šè‡ªåŠ¨å‘å‡º completed äº‹ä»¶ã€‚

**PublishSubject, ReplaySubject å’Œ BehaviorSubject æ˜¯ä¸ä¼šè‡ªåŠ¨å‘å‡º completed äº‹ä»¶çš„ã€‚**

#### å˜æ¢æ“ä½œ

- map

    é€šè¿‡ä¼ å…¥ä¸€ä¸ªå‡½æ•°é—­åŒ…æŠŠåŸæ¥çš„sequenceè½¬å˜ä¸ºä¸€ä¸ªæ–°çš„sequenceçš„æ“ä½œ

- flatmap

    å°†ä¸€ä¸ª sequence è½¬æ¢ä¸ºä¸€ä¸ª sequencesï¼Œå½“ä½ æ¥æ”¶ä¸€ä¸ª sequence çš„äº‹ä»¶ï¼Œä½ è¿˜æƒ³æ¥æ”¶å…¶ä»–sequence å‘å‡ºçš„äº‹ä»¶çš„è¯å¯ä»¥ä½¿ç”¨ flatMapï¼Œå¥¹ä¼šå°†æ¯ä¸€ä¸ª sequence äº‹ä»¶è¿›è¡Œå¤„ç†ä»¥åï¼Œç„¶åå†ä»¥ä¸€ä¸ªsequence å½¢å¼å‘å‡ºäº‹ä»¶ã€‚

- flatMapLatest æœ‰é—®é¢˜

    flatMapLateståªä¼šæ¥æ”¶æœ€æ–°çš„valueäº‹ä»¶ï¼Œå°†ä¸Šä¾‹æ”¹ä¸ºflatMapLatestã€‚ç»“æœä¸º

- scan ( <=> reduce)

    scanå°±æ˜¯ç»™ä¸€ä¸ªåˆå§‹åŒ–çš„æ•°ï¼Œç„¶åä¸æ–­çš„æ‹¿å‰ä¸€ä¸ªç»“æœå’Œæœ€æ–°çš„å€¼è¿›è¡Œå¤„ç†æ“ä½œã€‚

#### è¿‡æ»¤å’Œæ¡ä»¶æ“ä½œ

- filter

    filterå¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯è¿‡æ»¤æ‰æŸäº›ä¸ç¬¦åˆè¦æ±‚çš„äº‹ä»¶

- distinctUntilChanged

    distinctUntilChangedå°±æ˜¯å½“ä¸‹ä¸€ä¸ªäº‹ä»¶ä¸å‰ä¸€ä¸ªäº‹ä»¶æ˜¯ä¸åŒäº‹ä»¶çš„äº‹ä»¶æ‰è¿›è¡Œå¤„ç†æ“ä½œ

- elementAt

    åªå¤„ç†åœ¨æŒ‡å®šä½ç½®çš„äº‹ä»¶

- single

    æ‰¾å‡ºåœ¨ sequence åªå‘å‡ºä¸€æ¬¡çš„äº‹ä»¶ï¼Œå¦‚æœè¶…è¿‡ä¸€ä¸ªå°±ä¼šå‘å‡º error é”™è¯¯

- take

    åªå¤„ç†å‰å‡ ä¸ªäº‹ä»¶ä¿¡å·

- takeLast

    åªå¤„ç†åå‡ ä¸ªäº‹ä»¶ä¿¡å·

-  takeWhile

    å½“æ¡ä»¶æ»¡è¶³çš„æ—¶å€™è¿›è¡Œå¤„ç†

- takeuntil

    æ¥æ”¶äº‹ä»¶æ¶ˆæ¯ï¼Œç›´åˆ°å¦ä¸€ä¸ªsequenceå‘å‡ºäº‹ä»¶æ¶ˆæ¯çš„æ—¶å€™ã€‚

- skip

    å–æ¶ˆå‰å‡ ä¸ªäº‹ä»¶

- skipwhile

    æ»¡è¶³æ¡ä»¶çš„äº‹ä»¶æ¶ˆæ¯éƒ½å–æ¶ˆ (ä¸ºä»€ä¹ˆåªæœ‰ < æ‰æ»¡è¶³åŠŸèƒ½ï¼Œ > ä¸èµ·ä½œç”¨, æ˜¯ä¸æ˜¯åªè·³è¿‡å‰é¢æ»¡è¶³æ¡ä»¶çš„ï¼Œå½“é‡åˆ°ä¸æ»¡æ¡ä»¶çš„ä¹‹åï¼Œskip å¤±æ•ˆ)

- skipWhileWithIndex

    æ»¡è¶³æ¡ä»¶çš„éƒ½è¢«å–æ¶ˆï¼Œä¼ å…¥çš„é—­åŒ…åŒskipWhileæœ‰ç‚¹åŒºåˆ«è€Œå·²

- skipUntil

    ç›´åˆ°æŸä¸ªsequenceå‘å‡ºäº†äº‹ä»¶æ¶ˆæ¯ï¼Œæ‰å¼€å§‹æ¥æ”¶å½“å‰sequenceå‘å‡ºçš„äº‹ä»¶æ¶ˆæ¯

#### ç»„åˆæ“ä½œ

- startWith

    åœ¨å‘å‡ºäº‹ä»¶æ¶ˆæ¯ä¹‹å‰ï¼Œå…ˆå‘å‡ºæŸä¸ªç‰¹å®šçš„äº‹ä»¶æ¶ˆæ¯ã€‚æ¯”å¦‚å‘å‡ºäº‹ä»¶2 ï¼Œ3ç„¶åæˆ‘startWith(1)ï¼Œé‚£ä¹ˆå°±ä¼šå…ˆå‘å‡º1ï¼Œç„¶å2 ï¼Œ3.

- merge

    åˆå¹¶ä¸¤ä¸ªObservableæµåˆæˆå•ä¸ª Observable æµï¼Œæ ¹æ®æ—¶é—´è½´å‘å‡ºå¯¹åº”çš„äº‹ä»¶

- zip

    ç»‘å®šè¶…è¿‡æœ€å¤šä¸è¶…è¿‡8ä¸ªçš„Observableæµï¼Œç»“åˆåœ¨ä¸€èµ·å¤„ç†ã€‚æ³¨æ„Zipæ˜¯ä¸€ä¸ªäº‹ä»¶å¯¹åº”å¦ä¸€ä¸ªæµä¸€ä¸ªäº‹ä»¶ã€‚

- combineLatest

    ç»‘å®šè¶…è¿‡æœ€å¤šä¸è¶…è¿‡8ä¸ªçš„Observableæµï¼Œç»“åˆåœ¨ä¸€èµ·å¤„ç†ã€‚å’Œ Zip ä¸åŒçš„æ˜¯ combineLatest æ˜¯ä¸€ä¸ªæµçš„äº‹ä»¶å¯¹åº”å¦ä¸€ä¸ªæµçš„æœ€æ–°çš„äº‹ä»¶ï¼Œä¸¤ä¸ªäº‹ä»¶éƒ½ä¼šæ˜¯æœ€æ–°çš„äº‹ä»¶ï¼Œå¯å°†ä¸‹å›¾ä¸ Zip çš„å›¾è¿›è¡Œå¯¹æ¯”ã€‚

- switch

    switchLatestå¯ä»¥å¯¹äº‹ä»¶æµè¿›è¡Œè½¬æ¢ï¼Œæœ¬æ¥ç›‘å¬çš„subject1ï¼Œæˆ‘å¯ä»¥é€šè¿‡æ›´æ”¹variableé‡Œé¢çš„valueæ›´æ¢äº‹ä»¶æºã€‚å˜æˆç›‘å¬subject2äº†


#### æ•°å­¦å’Œé›†åˆè¿ç®—ç¬¦

- toArray

    å°† sequence è½¬æ¢æˆä¸€ä¸ªarrayï¼Œå¹¶è½¬æ¢æˆå•ä¸€äº‹ä»¶ä¿¡å·ï¼Œç„¶åç»“æŸ

- reduce (<=> scan)

    ç”¨ä¸€ä¸ªåˆå§‹å€¼ï¼Œå¯¹äº‹ä»¶æ•°æ®è¿›è¡Œç´¯è®¡æ“ä½œã€‚reduce æ¥å—ä¸€ä¸ªåˆå§‹å€¼ï¼Œå’Œä¸€ä¸ªæ“ä½œç¬¦å·

- concat

    concatä¼šæŠŠå¤šä¸ª sequence å’Œå¹¶ä¸ºä¸€ä¸ªsequenceï¼Œå¹¶ä¸”å½“å‰é¢ä¸€ä¸ª sequence å‘å‡ºäº†completed äº‹ä»¶ï¼Œæ‰ä¼šå¼€å§‹ä¸‹ä¸€ä¸ª sequence çš„äº‹ä»¶ã€‚

#### è¿æ¥æ“ä½œ (TODO ...)

- publish

    å°†ä¸€ä¸ªæ­£å¸¸çš„ sequence è½¬æ¢æˆä¸€ä¸ª connectable sequence

- replay

    å°†ä¸€ä¸ªæ­£å¸¸çš„ sequence è½¬æ¢æˆä¸€ä¸ª connectable sequenceï¼Œç„¶åå’Œ replaySubject ç›¸ä¼¼ï¼Œèƒ½æ¥æ”¶åˆ°è®¢é˜…ä¹‹å‰çš„äº‹ä»¶æ¶ˆæ¯ã€‚

- multicast
    
    å°†ä¸€ä¸ªæ­£å¸¸çš„ sequence è½¬æ¢æˆä¸€ä¸ª connectable sequenceï¼Œå¹¶ä¸”é€šè¿‡ç‰¹æ€§çš„subject å‘é€å‡ºå»ï¼Œæ¯”å¦‚ PublishSubjectï¼Œæˆ–è€… replaySubjectï¼ŒbehaviorSubject ç­‰ã€‚ä¸åŒçš„ Subject ä¼šæœ‰ä¸åŒçš„ç»“æœã€‚



#### åˆ†äº«é—®é¢˜åé¦ˆ

0. è¯­è¨€è¡¨è¾¾ï¼Œé—®é¢˜åè¯è¡¨è¾¾ä¸æ¸…ã€‚
1. é—®é¢˜å¤ªæ•£äº†ï¼ˆé€‰é¢˜å¤ªå¤§äº†ï¼Œç¼©å°èŒƒå›´ï¼‰ã€‚
2. åˆ†äº«ä¸»é¢˜ä¸é€ã€‚
3. è¡¨è¾¾é—®é¢˜éœ€è¦é€šè¿‡ä¸€äº›æ‰‹æ®µæ¥è¡¨è¿°é—®é¢˜ã€‚


