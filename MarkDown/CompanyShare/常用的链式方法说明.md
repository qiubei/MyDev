# 常用的链式方法说明

## 分享目的

1. 扫盲（有可能是个人盲区）。
2. 简单了解什么是函数式变成。
3. 了解一些方法的基本使用。
4. 个人提升。

## 函数式编程说明（云里雾里，照本宣科）

。。。

## RxSwift 基础 

**链式编程的设计共性**

- 事件状态
- 互斥信号
- 事件队列

~~~ installer
// installer

public final class Signal<T> {
    
    fileprivate var value: Result<T>?
    fileprivate var callbacks: [(Result<T>) -> Void] = []
    fileprivate let mutex = Mutex() // 互斥信号
    ...
}
~~~

~~~Promise
// Promise

public final class Promise<Value> {
    
    private var state: State<Value>
    private let lockQueue = DispatchQueue(label: "promise_lock_queue", qos: .userInitiated)
    private var callbacks: [Callback<Value>] = []
    ...
}
~~~

RxSwift 理论上是差不多的，但是...

~~~swift 
/// Type of elements in sequence.
    public typealias E = Element
    
    init() {
#if TRACE_RESOURCES
        _ = Resources.incrementTotal()
#endif
    }
    
    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
        rxAbstractMethod()
    }
    
    public func asObservable() -> Observable<E> {
        return self
    }
    
    deinit {
#if TRACE_RESOURCES
        _ = Resources.decrementTotal()
#endif
    }

    // this is kind of ugly I know :(
    // Swift compiler reports "Not supported yet" when trying to override protocol extensions, so ¯\_(ツ)_/¯

    /// Optimizations for map operator
    internal func composeMap<R>(_ transform: @escaping (Element) throws -> R) -> Observable<R> {
        return _map(source: self, transform: transform)
    }
~~~

**Rxswift 基本构成要素**
- ObservableType 是一个 `protocol`， 所有拥有链式能力都必须实现这个协议。

~~~
    func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E
    
    public func asObservable() -> Observable<E> {
        // temporary workaround
        //return Observable.create(subscribe: self.subscribe)
        return Observable.create { o in
            return self.subscribe(o)
        }
    }
~~~

- ObserverType 也是协议：分两层：一个是实现 observable 的人调用，一个给观察者调用

~~~
    /// Notify observer about sequence event.
    ///
    /// - parameter event: Event that occurred.
    func on(_ event: Event<E>)  
    
    
    /// Convenience method equivalent to `on(.next(element: E))`
    ///
    /// - parameter element: Next element to send to observer(s)
    public func onNext(_ element: E) {
        self.on(.next(element))
    }
    
    /// Convenience method equivalent to `on(.completed)`
    public func onCompleted() {
        self.on(.completed)
    }
    
    /// Convenience method equivalent to `on(.error(Swift.Error))`
    /// - parameter error: Swift.Error to send to observer(s)
    public func onError(_ error: Swift.Error) {
        self.on(.error(error))
    }

~~~


```请不要再 bb 了，告诉我什么函数是编程。。。SHOW ME THE CODE!!!```

## RxSwift simple Demo

~~~
let disposeBag = DisposeBag()
let faces = Observable<String>.create { observerOfString in
    print("Observable created")
    observerOfString.on(.next("😉"))
    observerOfString.on(.next("🐰"))
    observerOfString.on(.next("🐶"))
    observerOfString.on(.completed)
    return Disposables.create()
    }

faces.subscribe { (event) in
    print(event)
}.disposed(by: disposeBag)
/// console log
/*
 Hello world1
 Observable created
 next(😉)
 next(🐰)
 next(🐶)
 completed
 */
~~~

## 方法列表

#### 创建和订阅 Observable

- create

    我们也可以自定义可观察的 sequence，那就是使用 create
- never

    never 就是创建一个 sequence，但是不发出任何事件信号。
    
- empty sequence

    empty就是创建一个空的sequence,只能发出一个 .completed 事件

- just

    just是创建一个 sequence 只能发出一种特定的事件，能正常结束.
    
- of

    of 是创建一个 sequence 能发生很多种事件信号
    
- from

    from 就是从集合中创建 sequence，例如数组，字典或者Set    
    
- range (有点疑惑，为什么只能使用整型数据)

    range就是创建一个 sequence，他会发出这个范围中的从开始到结束的所有事件
    
- repeatElement
    
    创建一个sequence，发出特定的事件n次
    
- generate

    generate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件
    
- deferred

    deferred 会为每一为订阅者 observer 创建一个新的可观察序列
    
- error

    创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束
    
- doOn
    
    doOn我感觉就是在直接onNext处理时候，先执行某个方法，doOnNext( :)方法就是在subscribe(onNext:)前调用，doOnCompleted(:)就是在subscribe(onCompleted:)前面调用的。
    
#### subjects

```DMEO```

~~~ 
let subject1 = PublishSubject<String>()
let subject2 = PublishSubject<String>()
Observable.of(subject1, subject2)
    .merge()
    .subscribe(onNext: {print("mergae -- \($0)")} )
    .disposed(by: disposeBag)
subject1.onNext("a")
subject1.onNext("b")
subject2.onNext("1")
subject2.onNext("2")
subject1.onNext("c")
subject2.onNext("3")
subject1.onNext("d")

~~~


Subjet 是 observable 和 Observer 之间的桥梁，一个 Subject 既是一个 Obserable 也是一个 Observer，他既可以发出事件，也可以监听事件。

- publishsubject

PublishSubject会发送订阅者从订阅之后的事件序列。

- replay subject


    当你订阅 ReplaySubject 的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与 bufferSize 的大小
    
- BehaviorSubject

- variable

    Variable 是 BehaviorSubject 一个包装箱，就像是一个箱子一样，使用的时候需要调用 asObservable() 拆箱，里面的 value 是一个 BehaviorSubject ，他不会发出 error 事件，但是会自动发出 completed 事件。

**PublishSubject, ReplaySubject 和 BehaviorSubject 是不会自动发出 completed 事件的。**

#### 变换操作

- map

    通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作

- flatmap

    将一个 sequence 转换为一个 sequences，当你接收一个 sequence 的事件，你还想接收其他sequence 发出的事件的话可以使用 flatMap，她会将每一个 sequence 事件进行处理以后，然后再以一个sequence 形式发出事件。

- flatMapLatest 有问题

    flatMapLatest只会接收最新的value事件，将上例改为flatMapLatest。结果为

- scan ( <=> reduce)

    scan就是给一个初始化的数，然后不断的拿前一个结果和最新的值进行处理操作。

#### 过滤和条件操作

- filter

    filter很好理解，就是过滤掉某些不符合要求的事件

- distinctUntilChanged

    distinctUntilChanged就是当下一个事件与前一个事件是不同事件的事件才进行处理操作

- elementAt

    只处理在指定位置的事件

- single

    找出在 sequence 只发出一次的事件，如果超过一个就会发出 error 错误

- take

    只处理前几个事件信号

- takeLast

    只处理后几个事件信号

-  takeWhile

    当条件满足的时候进行处理

- takeuntil

    接收事件消息，直到另一个sequence发出事件消息的时候。

- skip

    取消前几个事件

- skipwhile

    满足条件的事件消息都取消 (为什么只有 < 才满足功能， > 不起作用, 是不是只跳过前面满足条件的，当遇到不满条件的之后，skip 失效)

- skipWhileWithIndex

    满足条件的都被取消，传入的闭包同skipWhile有点区别而已

- skipUntil

    直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息

#### 组合操作

- startWith

    在发出事件消息之前，先发出某个特定的事件消息。比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3.

- merge

    合并两个Observable流合成单个 Observable 流，根据时间轴发出对应的事件

- zip

    绑定超过最多不超过8个的Observable流，结合在一起处理。注意Zip是一个事件对应另一个流一个事件。

- combineLatest

    绑定超过最多不超过8个的Observable流，结合在一起处理。和 Zip 不同的是 combineLatest 是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与 Zip 的图进行对比。

- switch

    switchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了


#### 数学和集合运算符

- toArray

    将 sequence 转换成一个array，并转换成单一事件信号，然后结束

- reduce (<=> scan)

    用一个初始值，对事件数据进行累计操作。reduce 接受一个初始值，和一个操作符号

- concat

    concat会把多个 sequence 和并为一个sequence，并且当前面一个 sequence 发出了completed 事件，才会开始下一个 sequence 的事件。

#### 连接操作 (TODO ...)

- publish

    将一个正常的 sequence 转换成一个 connectable sequence

- replay

    将一个正常的 sequence 转换成一个 connectable sequence，然后和 replaySubject 相似，能接收到订阅之前的事件消息。

- multicast
    
    将一个正常的 sequence 转换成一个 connectable sequence，并且通过特性的subject 发送出去，比如 PublishSubject，或者 replaySubject，behaviorSubject 等。不同的 Subject 会有不同的结果。



#### 分享问题反馈

0. 语言表达，问题名词表达不清。
1. 问题太散了（选题太大了，缩小范围）。
2. 分享主题不透。
3. 表达问题需要通过一些手段来表述问题。


