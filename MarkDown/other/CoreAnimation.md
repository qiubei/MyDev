# CoreAnimation

不要被这个名字给忽悠了，他讲的不只是动画，动画只是一个方面，其实他主要的讲的是 layer 相关的
### Layer vs View

view 不能做而 layer 能做的内容：

1. 阴影、圆角，带颜色的边框
2. 3D 变换
3. 非矩形范围 ？
4. 透明遮罩
5. 多级非线性动画 ？

**view**

* 显示内容（图片、文本、视频等）。
* 可以相互嵌套。
* 响应用户事件。
* 动画
* auto layout

**layer**

* 显示内容（图片、文本、视频等）。
* 可以相互嵌套。
* 动画
* **不响应用户事件。** iOS 是根据视图层级来传递事件的

## 绘制

### iOS layer

bounds、frame 和 单位坐标

首先先得知道坐标的几个概念

1. 点： 是虚拟的像素，也被称为逻辑像素。标准的设备上 1 个点就是一个像素。
2. 像素：物理设备成像的基本单位
3. 单位：相对自身而言，把自己当做一个单位坐标{0, 0, 1, 1}

1. bounds 
2. frame
3. 单位坐标

<!--两种情况下呈现图会变得很有用，一个是同步动画，一个是处理用户交互。-->

### CALayer

* CALayer 潜藏着一个 MVC 结构：layer（view）， Core Animation (controller)非现实的控制、model（呈现图或模型层（layer 一些属性：现实和动画的数据模型））
* 隐式动画过程。（原理是什么？）



## 动画
### 基于定时帧的动画 
**Runloop**
iOS上的每个线程都管理了一个Runloop，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：

* 处理触摸事件
* 发送和接受网络数据包
* 执行使用gcd的代码
* 处理计时器行为
* 屏幕重绘

误区：周期不是固定的。（采用 while 循环理解）

**NSTimer**
timer 由自己定义的时间触发。
当我们设置一个NSTimer，他会被插入到 runloop 当前任务列表中，然后直到指定时间过去之后才会被执行。（需要等上一个任务完成之后开始执行）

缺点： 延迟卡顿

**CADisplayLink**

* CADisplayLink 由硬件决定，每秒刷新 60 次。
* 掉帧的本质。

缺点： 当有系统资源紧张时，将出现掉帧卡顿。

## 性能

由于历史原因，我们可以说 CPU 所做的工作都在软件层面，而 GPU 在硬件层面。 总的来说，我们可以用软件（使用 CPU ）做任何事情，但是对于图像处理，通常用硬件会更快，因为 GPU 使用图像对高度并行浮点运算做了优化。

### CPU 和 GPU

当运行一段动画时候，这个过程会被四个分离的阶段被打破：

* 布局 - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。

* 显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径。

* 准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。

* 提交 - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。”

* 对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染

* 在屏幕上渲染可见的三角形


